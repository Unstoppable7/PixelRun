using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class MapPart{
    //Guarda los tiles que estarán en linea recta
    public List<GameObject> straightTiles = new List<GameObject>();
    
    //Guarda los tiles que giran a la izquierda el mapa
    public List<GameObject> rightTiles = new List<GameObject>();
    
    //Guarda los tiles que giran a la derecha el mapa
    public List<GameObject> leftTiles = new List<GameObject>();

    //Variable aleatorea que contendrá la cantidad de tiles que
    //tendrá cada parte del mapa cada vez que empieza a jugar
    //se inicializa en el start
    [HideInInspector]
    public int tilesCount;

    //Minimo de tiles que puede tener la parte del mapa
    [Range(10, 500)]
    public int minTilesCount;

    //Maximo de tiles que puede tener la parte del mapa
    [Range(10, 500)]
    public int maxTilesCount;

    //Asigna la cantidad aleatorea de tiles que tendrá la parte del mapa
    public void RandomTilesCount(){
        tilesCount = Random.Range(minTilesCount, maxTilesCount);
    }
}

public class LevelManager : MonoBehaviour
{
    //Singleton
    public static LevelManager sharedInstance { set; get; }

    //Referencia al transform del personaje
    Transform playerTransform;

    //Posicion en el eje Z del spawn de los tiles
    float spawnZ = 0.0f;

    //Tamaño en largo de los tiles
    float tileLenght = 6f;

    //Cantidad de tiles en pantalla
    int amountTiles = 20;

    //Zona segura donde podremos eliminar un tile porque ya está fuera de
    //pantalla
    float safeZone = 20f;

    //Index del ultimo tile creado
    int lastTileIndex;

    //Lista de tiles actualmente en pantalla
    //la inicializamos en un proceso mas adelante
    List<GameObject> activeTiles;

    //Guarda el lado hacia donde se instancian los nuevos tiles
    // -1 izquierda ---- 0 recto ---- +1 derecha
    int side = 0;

    //Lados al que puede girar la creacion de tiles -1 izquierda ---- 1 derecha
    //se elige aleatoreamente la dirección si es izquierda o derecha
    readonly int[] DIRECTIONS = {-1, 1};

    //Guarda la direccion que tendran que seguir los tiles
    Transform tileDirection;

    GameObject initPositionTileDirection;

    //Minimo valor que tendrá la siguiente curva
    int minNextCurve = 6;

    //Maximo valor que tendrá la siguiente curva
    int maxNextCurve = 20;

    //Cantidad de tiles desde la ultima curva
    int tilesCount = 0;

    //Guarda la posicion del ultimo tile que hace que el jugador
    //sea inmune se asigna en el metodo Inmunity del jugador
    //cuando se destruya ese ultimo tile de inmunidad la variable
    //inmune de jugador se vuelve false
    int lastImmunityTile;

    //Cantidad de tiles despues de la ultima curva
    //se legie aleatoreo entre los valores minNextCurve y maxNextCurve
    int nextCurve;

    #region Variables para la creación de partes del mapa
    
    //Lista con las partes del mapa
    [SerializeField]
    List<MapPart> mapParts;

    //La parte del mapa actual (la que se estará creando)
    MapPart currentPart;

    //Cantidad de tiles que se han creado por cada parte del mapa
    int partTilesCount = 0;

    #endregion

    void Awake(){
        if (!sharedInstance)
        {
            sharedInstance = this;
        }
        else
        {
            Destroy(gameObject);
        }

        //Inicializamos la cantidad de tiles que tendrá cada parte
        foreach (MapPart part in mapParts){
            part.RandomTilesCount();
        }

        //La parte que se creará será la primera al inicio
        currentPart = mapParts[0];
    }

    // Start is called before the first frame update
    void Start()
    {
        //Referenciamos el transform del personaje
        playerTransform = GameObject.FindGameObjectWithTag("Player").transform;
        
        //Referencia al transform que está en la escena dentro del LevelManager object
        tileDirection = GameObject.Find("TileDirection").transform;

        initPositionTileDirection = new GameObject();
        initPositionTileDirection.transform.position = tileDirection.position;
        initPositionTileDirection.transform.rotation = tileDirection.rotation;

        //Inicializamos la lista de los tiles activos
        activeTiles = new List<GameObject>();

<<<<<<< HEAD
        //Se crea la primera curva del mapa
        nextCurve = Random.Range(minNextCurve, maxNextCurve);

        //Cargamos los tiles iniciales
        for (int i = 0; i < amountTiles; i++)
        {
            //Nos aseguramos que ni el primero ni el segundo de los tiles
            //tenga un obstaculo en el centro, por lo que le forzamos a poner 
            //el tile que se encuentra en la posicion 0 (debemos asegurarnos 
            //que este no tiene obstaculos en el centro)
            if (i < 2)
            {
                //Al inicio del juego, se eligen los dos primeros tiles 
                //(esos dos primeros son seguros en el centro)
                //La posición 0 contendrá el tile de inicio de la priemra parte del mapa
                //la posición 1 tambien será seguro en el centro
                SpawnTile(i);
            }

            else //Despues del 2do tile generamos aleatorios
            {
                SpawnTile();
            }
           
        }
=======
        //Generamos los tiles iniciales
        InitSpawn();
>>>>>>> clean_code
    }

    // Update is called once per frame
    void Update()
    {
        //Si el jugador no está corriendo que no haga nada
        if(!GameManager.sharedInstance.IsPlayerRunning()){
            return;
        }

        //Si la posicion del jugador en z menos la zona segura es mayor a
        //que la posicion que hacemos spawn los tiles menos la multiplicacion
        //entre la cantidad de tiles en pantalla y el largo de c/u de ellos
        //creamos un nuevo tile

        if (Vector3.Distance(playerTransform.position, activeTiles[0].transform.position) > safeZone)
        {
            //Creamos un nuevo tile en nuestro camino
            SpawnTile();

            //Eliminamos el ultimo tile
            DeleteLastTile();

            //Si el tile hasta donde el jugador es inmune es mayor a 4
            //mayor a 4 para tomar en cuenta los tiles que no
            //han sido destruidos aun
            if(lastImmunityTile > 4){
                //Se va restando cuando se elimina un tile anterior ya que tambien se va
                //disminuyendo
                lastImmunityTile--;
            }

            else{
                //Cuando ya se haya eliminado el ultimo tile hasta donde el jugador es inmune
                //volvemos false la variable inmune del jugador
                GameManager.sharedInstance.SetImmunePlayer(false);
            }
        }
    }

    //Spawn inicial de los tiles 
    public void InitSpawn()
    {
        //Asignamos valor inicial a las variables
        spawnZ = 0.0f;
        tilesCount = 0;        
        tileDirection.position = initPositionTileDirection.transform.position;
        tileDirection.rotation = initPositionTileDirection.transform.rotation;        

        //Se crea la primera curva del mapa
        nextCurve = Random.Range(minNextCurve, maxNextCurve);

        //Cargamos los tiles iniciales
        for (int i = 0; i < amountTiles; i++)
        {
            //Nos aseguramos que ni el primero ni el segundo de los tiles
            //tenga un obstaculo en el centro, por lo que le forzamos a poner 
            //el tile que se encuentra en la posicion 0 (debemos asegurarnos 
            //que este no tiene obstaculos en el centro)
            if (i < 2)
            {
                SpawnTile(0);

            }
            else //Despues del 2do tile generamos aleatorios
            {
                SpawnTile();
            }

        }
    }

    //Metodo para spawnear o aparecer un tile en pantalla
    //prefabIndex: Nos indica que tile de la lista vamos a spawnear
    public void SpawnTile(int prefabIndex = -1)
    {    
        //Objeto que tendrá el tile instanciado
        GameObject tile;

        //Instanciamos en el game object el tile de la lista correspodiente
        //al index indicado
        if(prefabIndex == -1)
        {
            //Si se llama sin especificar, por defecto busco uno aleatorio
            //Si es momento de crear la curva
            if(nextCurve - tilesCount == 0){
                //Se elige una direccion aleatorea
                side = DIRECTIONS[Random.Range(0, DIRECTIONS.Length)];

                //Si la siguiente curva y la cantidad de tiles de la parte actual son iguales
                //(si la proxima curva será el inicio de la proxima parte)
                if(nextCurve - currentPart.tilesCount == 0){
                    //atrasamos la curva 1 tile mas para que se pueda poner el prefab
                    //de inicio de la parte siguiente del mapa
                    nextCurve++;
                    side = 0;
                }

                else{
                    //Se elige la cantidad de tiles de la siguiente curva
                    nextCurve = Random.Range(minNextCurve, maxNextCurve);
                }

                //Se asigna a cero la cantidad de tiles despues de la curva ya que se crea una nueva curva
                tilesCount = 0;
            }

            else{
                side = 0;
            }


            //Si la direccion va en linea recta
            //instancia los tiles de linea recta
            if(side == 0){
                //El primer tile de la nueva parte del mapa será el prefab en la posición 0 del array
                //Solo se instancia una vez este prefab durante toda la creción de la nueva parte
                //Ya que este le va a indicar al usuario que está entrando a la nueva parte del mapa
                if(partTilesCount < 1){
                    tile = Instantiate(currentPart.straightTiles[0]) as GameObject;
                }

                else if(partTilesCount < 2){
                    tile = Instantiate(currentPart.straightTiles[1]) as GameObject;
                }

                //Los dos tiles despues de la curva y la entrada a la nueva parte serán seguros en el centro
                else if(tilesCount < 3){
                    //Se instancia el de la posicion 1 ya que el de la posición 0 es la entrada a la nueva parte
                    //(Solo queremos que se instancie la entrada a esa parte una sola vez)
                    tile = Instantiate(currentPart.straightTiles[1]) as GameObject;
                }

                //Si siguen los prefabs en linea recta (no hay una curva antes)
                else{
                    //Colocamos desde el 1 hasta el ultimo prefab del array que tiene los prefabs en direccion recta
                    //Comienza en 1 porque queremos que la posición 0 de los array en linea recta
                    //contenga el prefab de inicio de esa parte
                    tile = Instantiate(currentPart.straightTiles[RandomTileIndex(1, currentPart.straightTiles.Count)]) as GameObject;
                }
            }

            //Si la direccion cambia a la derecha
            //instancia los tiles de derecha
            else if(side == 1){
                tile = Instantiate(currentPart.rightTiles[RandomTileIndex(0, currentPart.rightTiles.Count)]) as GameObject;
            }

            //Si la direccion cambia a la izquierda
            //instancia los tiles de izquierda
            else{
                tile = Instantiate(currentPart.leftTiles[RandomTileIndex(0, currentPart.leftTiles.Count)]) as GameObject;
            }
        }
        else
        {
            tile = Instantiate(currentPart.straightTiles[prefabIndex]) as GameObject;
        }

        //Hacemos padre del tile a este objeto LevelManager
        tile.transform.SetParent(transform);

        //Posicionamos este nuevo tile en el lugar indicado por la var spawnZ
        //Lo multiplicamos por forward ya que este vector es 1 en z
        //Se crean los primeros dos tiles en linea recta
        if(activeTiles.Count < 2){
            tile.transform.position = Vector3.forward * spawnZ;

            //Sumamos al valor de posicion spawnZ el tamaño del tile
            spawnZ += tileLenght;
        }

        else{
            //Se posiciona el nuevo tile tomando como referencia la posicion del tile anterior
            //y se usa la direccion local de tileDirecion (tileDirecion.forward) para que se siga colocando en linea recta
            //dependiendo de hacia donde esté rotado ese transform, como se usa como referencia el tile anterior obteniendo
            //su posicion solo es necesario agregarle el tamaño del tile para que se coloque en la nueva posicion y hacia la nueva direccion
            tile.transform.position = activeTiles[activeTiles.Count-1].transform.position + tileDirection.forward * tileLenght;

            //Se cambia la direccion hacia adelande local de tileDirecion para que el forward se actualize y sea
            //la nueva direccion de los proximos tiles en linea recta
            //se actualiza despues de la posicion para que el siguiente tile tenga en cuenta el giro y no el actual
            tileDirection.rotation *= Quaternion.Euler(Vector3.up * side * 90);

            //Si se mantiene en linea recta sigue la direccion de rotacion local
            if (side == 0){
                tile.transform.rotation = tileDirection.rotation;
            }

            //Si hay un giro en el mapa, el tile de giro mantiene la rotación normal (igual que el anterior)
            //ya que este no girará si no los de linea recta que vienen despues del giro
            else{
                tile.transform.rotation = activeTiles[activeTiles.Count-1].transform.rotation;
            }
        }

        //Añadimos este nuevo tile a la lista de tiles activos
        activeTiles.Add(tile);

        //Se aumenta la cantidad de tiles creados despues de una curva
        tilesCount++;

        //Se aumenta la cantidad de tiles de una parte del mapa
        partTilesCount++;

        //Si la cantidad de tiles de la parte del mapa llega al limite
        if(currentPart.tilesCount - partTilesCount == 0){
            //Se selecciona la parte siguiente del array de partes del mapa
            int nextIndex = mapParts.IndexOf(currentPart) + 1;

            //Si es la ultima parte se regresa a la primera
            if(nextIndex >= mapParts.Count){
                nextIndex = 0;
            }
            
            //Se reasigna la parte actual que se va a empezar a instanciar
            currentPart = mapParts[nextIndex];

            //Se regresa a 0 la cantidad de tiles de la nueva parte del mapa
            //que se va a empezar a crear
            partTilesCount = 0;
        }
    }

    //Metodo para eliminar los tiles que van quedando atras
    public void DeleteLastTile()
    {
        //Destruimos el primer tile de la lista
        Destroy(activeTiles[0]);
        //Removemos de la lista el primero espacio para que se reordene
        activeTiles.RemoveAt(0);
    }

    //Metodo para eliminar todos los tiles activos en el juego.
    public void DeleteAllTiles()
    {
        //Almacenamos el total de tiles activos en este momento, para poder
        //recorrer la totalidad de la lista, porque al irse eliminando
        //va disminuyendo esta variable
        int totalActiveTiles = activeTiles.Count;
        for (int i = 0; i < totalActiveTiles; i++)
        {
            //Destruimos el primer objeto
            Destroy(activeTiles[0]);
            //Removemos el primer objeto y esto mueve toda la lista
            //quedando de primero el que estaba de segundo, por esto
            //siempre eliminamos el tile que este de primero
            activeTiles.RemoveAt(0);
        }        
    }

    //Metodo para generar un index aleatorio de nuestros tiles
    //recibe como parametro la cantidad de items de cada lista
    int RandomTileIndex(int initIndex, int listCount)
    {
        //Si nuestra lista de tiles totales está vacia o tiene solo 1
        //no tenemos de donde seleccionar aleatoriamente
        if (listCount <= 1)
        {
            return 0;
        }

        //Igualamos el ultimo tile creado para evitar que salgan dos seguidos
        int randomIndex = lastTileIndex;

        //Mientras sean iguales el ultimo con el random, buscame otro
        while(randomIndex == lastTileIndex)
        {
            randomIndex = Random.Range(initIndex, listCount);
        }

        //Reescribimos el index del ultimo tile creado
        lastTileIndex = randomIndex;

        //Retornamos el index aleatorio
        return randomIndex;
    }

    //Guarda la ultima posicion del tile hasta donde el jugador será inmune
    public void SetLastImmunityTile(){
        lastImmunityTile = activeTiles.Count-1;
    }
}
